import java.util.*;

class Solution {
    public int solution(int bridge_length, int weight, int[] truck_weights) {
        //1초에 한칸씩 움직이는 다리 라고 생각하고 선입 선출 형태의 큐 만듦
        Queue<Integer> bridge = new ArrayDeque<>();
        for (int i = 0; i < bridge_length; i++) {
            //입력받는 다리 길이(bridge_length) 만큼 큐 길이 동적 조절
            //offer을 사용해 입력받은 다리길이 만큼 무게 0으로 초기화
            bridge.offer(0);
        }

        int time = 0;            // 경과 시간
        int bridgeWeight = 0;    // 현재 다리 위 총 무게
        int truckIndex = 0;      // 트럭 순서 제어용

        //truck_weights(트럭 무게담은 배열) -> 배열의 개수 -> 트럭이 몇대인지 알 수 있음
        while (truckIndex < truck_weights.length) {
            //경과 시간 제어(1초 증가)
            time++;

            // 다리를 한칸 밀기(poll을 사용해 큐의 가장 앞 원소 꺼내서 제거)
            bridgeWeight = bridgeWeight - bridge.poll();

            //다음 트럭 무게 입력
            int nextTruck = truck_weights[truckIndex];

            // 트럭 올릴 수 있는지 체크 (다리무게 + 트럭무게 <= 다리 기준 무게)
            if (bridgeWeight + nextTruck <= weight) {
                //입력받은 트럭 무게 큐에 진입
                bridge.offer(nextTruck);
                //다리무게 증가 시킴
                bridgeWeight = bridgeWeight + nextTruck;
                //트럭 순서 증가
                truckIndex++;
            } else {
                bridge.offer(0);
            }
        }
        // 트럭이 올라갔을때만 타임을 증가 시켰기때문에 빠져나오는 시간(다리길이만큼) 만큼 더함
        return time + bridge_length;
    }
}

public class Main {
    public static void main(String[] args) {
        Solution sol = new Solution();

        // 더미 데이터
        int bridge_length = 2;
        int weight = 10;
        int[] truck_weights = {7, 4, 5, 6};

        int result = sol.solution(bridge_length, weight, truck_weights);
        System.out.println("답은?! : " + result);
    }
}
